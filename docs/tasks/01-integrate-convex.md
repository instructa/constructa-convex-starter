Love this ADR. It’s crisp, pragmatic, and it leans on exactly the pieces that have matured lately:

* **Convex is now self‑hostable** (Docker images + OSS dashboard), so you can run the same backend as the cloud with minimal infra. ([docs.convex.dev][1])
* **Presence** is available as an official, OSS **Convex Component** you can drop in and extend (note the npm scope is `@convex-dev/presence`). ([Convex][2])
* **TanStack Start** hit **v1 RC on Sep 23, 2025**, making it a solid match for your SSR/streaming and file-based routing needs. ([TanStack][3])
* **Convex Auth** is indeed **beta**; it’s the quickest way to get started and can be swapped for OIDC later. ([docs.convex.dev][4])
* Convex’s **row‑level security patterns** are documented and map nicely to your memberships/roles. ([Convex Stack][5])
* If collaborative rich text becomes important, there’s an official **ProseMirror sync** component you can add later. ([Convex][6])

Below is the “tiny repo layout” plus baseline code that matches your ADR and gets you to staging quickly. It includes the self‑hosted bits, presence+cursors, LWW/locking, auth checks, and a TanStack Start route for `/board/$boardId`.

---

## Minimal repo layout

```
collab-board/
├─ convex/
│  ├─ convex.config.ts          # mounts the Presence component
│  ├─ schema.ts                 # boards, memberships, notes, locks, cursors
│  ├─ auth.ts                   # helpers: requireUser, requireMember/role
│  ├─ rls.ts                    # row-level security checks
│  ├─ notes.ts                  # notes.list (live), notes.upsert/move/text
│  ├─ presence.ts               # wire up @convex-dev/presence + cursor pulses
│  └─ _generated/…              # generated by Convex
├─ src/
│  ├─ main.tsx                  # bootstraps client
│  ├─ app.tsx                   # Convex provider + app shell
│  ├─ routes/
│  │  ├─ __root.tsx
│  │  └─ board.$boardId.tsx     # board page: notes + presence + cursors
│  ├─ components/
│  │  ├─ BoardCanvas.tsx
│  │  ├─ NoteCard.tsx
│  │  └─ CursorLayer.tsx
│  └─ lib/
│     ├─ throttle.ts
│     └─ session.ts             # per-tab session id
├─ docker/
│  └─ docker-compose.yml        # self-hosted Convex backend + dashboard
├─ .env.example
├─ package.json
├─ tsconfig.json
└─ README.md
```

---

## Server: Convex setup

### `convex/convex.config.ts`

```ts
import { defineApp } from "convex/server";
import presence from "@convex-dev/presence/convex.config";

const app = defineApp();
app.use(presence); // mounts presence functions under api.presence.*
export default app;
```

(Official Presence component usage.) ([Convex][2])

### `convex/schema.ts`

```ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  boards: defineTable({
    name: v.string(),
    // If you're using Convex Auth users table, switch these to v.id("users")
    createdBy: v.string(),
    createdAt: v.number(),
  }),
  memberships: defineTable({
    boardId: v.id("boards"),
    userId: v.string(),
    role: v.union(v.literal("READ"), v.literal("WRITE"), v.literal("ADMIN")),
  })
    .index("by_board", ["boardId"])
    .index("by_user", ["userId"]),

  notes: defineTable({
    boardId: v.id("boards"),
    x: v.number(), y: v.number(),
    width: v.number(), height: v.number(),
    text: v.string(),
    color: v.string(),
    z: v.number(),
    createdBy: v.string(),
    updatedAt: v.number(),
  }).index("by_board", ["boardId"]),

  // Optional lightweight locks for editing text
  locks: defineTable({
    noteId: v.id("notes"),
    userId: v.string(),
    // expiresAt is checked in server code; a cron can clean stale locks
    expiresAt: v.number(),
  }).index("by_note", ["noteId"]),

  // Separate, ephemeral cursor pulses (presence component handles join/leave)
  cursors: defineTable({
    boardId: v.id("boards"),
    sessionId: v.string(), // per-tab
    userId: v.string(),
    name: v.string(),
    color: v.string(),
    x: v.number(),
    y: v.number(),
    updatedAt: v.number(), // filter recent only
  })
    .index("by_board", ["boardId"])
    .index("by_board_session", ["boardId", "sessionId"]),
});
```

> Why a separate `cursors` table? The Presence component focuses on room membership / liveness with efficient updates. Cursor streams are high‑frequency, so keeping them in a tiny indexed table you **filter by freshness** avoids invalidating presence subscriptions with every pointer move, and lets you quantize/throttle client‑side independently. ([Convex][2])

### `convex/auth.ts`

```ts
import { QueryCtx, MutationCtx } from "./_generated/server";

export async function requireUser(ctx: QueryCtx | MutationCtx) {
  const ident = await ctx.auth.getUserIdentity();
  if (!ident) throw new Error("Unauthorized");
  return ident;
}

export async function requireMember(
  ctx: QueryCtx | MutationCtx,
  boardId: string,
  minRole: "READ" | "WRITE" | "ADMIN" = "READ",
) {
  const user = await requireUser(ctx);
  const membership = await ctx.db
    .query("memberships")
    .withIndex("by_user", q => q.eq("userId", user.subject))
    .filter(q => q.eq(q.field("boardId"), boardId))
    .first();

  if (!membership) throw new Error("Forbidden");
  const order = { READ: 0, WRITE: 1, ADMIN: 2 } as const;
  if (order[membership.role] < order[minRole]) throw new Error("Forbidden");
  return { user, membership };
}
```

### `convex/rls.ts` (row‑level security helpers)

```ts
import { QueryCtx, MutationCtx } from "./_generated/server";
import { requireMember } from "./auth";

export async function canReadBoard(ctx: QueryCtx, boardId: string) {
  await requireMember(ctx, boardId, "READ");
}

export async function canWriteBoard(ctx: MutationCtx, boardId: string) {
  await requireMember(ctx, boardId, "WRITE");
}
```

(Borrowing the documented RLS approach—guard every function and keep reads scoped by `boardId` + index.) ([Convex Stack][5])

### `convex/notes.ts`

```ts
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
import { canReadBoard, canWriteBoard } from "./rls";

export const list = query({
  args: { boardId: v.id("boards") },
  handler: async (ctx, { boardId }) => {
    await canReadBoard(ctx, boardId);
    return await ctx.db
      .query("notes")
      .withIndex("by_board", q => q.eq("boardId", boardId))
      .collect();
  },
});

export const upsert = mutation({
  args: {
    // create or move/update
    noteId: v.optional(v.id("notes")),
    boardId: v.id("boards"),
    x: v.number(), y: v.number(),
    width: v.number(), height: v.number(),
    text: v.string(),
    color: v.string(),
    z: v.number(),
    // For LWW guard; client sends last seen timestamp (ms)
    expectedUpdatedAt: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    await canWriteBoard(ctx, args.boardId);
    const user = await ctx.auth.getUserIdentity();
    const now = Date.now();

    if (args.noteId) {
      const existing = await ctx.db.get(args.noteId);
      if (!existing) throw new Error("Note not found");
      // Simple LWW conflict resolution:
      if (args.expectedUpdatedAt && existing.updatedAt > args.expectedUpdatedAt) {
        // Keep server state; still accept z/pos to reduce UI jank or just return
        return existing;
      }
      await ctx.db.patch(args.noteId, {
        x: args.x, y: args.y, width: args.width, height: args.height,
        text: args.text, color: args.color, z: args.z, updatedAt: now,
      });
      return await ctx.db.get(args.noteId);
    } else {
      const id = await ctx.db.insert("notes", {
        boardId: args.boardId,
        x: args.x, y: args.y, width: args.width, height: args.height,
        text: args.text, color: args.color, z: args.z,
        createdBy: user?.subject ?? "anon",
        updatedAt: now,
      });
      return await ctx.db.get(id);
    }
  },
});
```

### `convex/presence.ts`

```ts
import { mutation, query } from "./_generated/server";
import { components } from "./_generated/api";
import { v } from "convex/values";
import { Presence } from "@convex-dev/presence";

// Wire up the official Presence component
export const presence = new Presence(components.presence);

// Heartbeat/list/disconnect wrappers (add RLS where appropriate)
export const heartbeat = mutation({
  args: { roomId: v.string(), userId: v.string(), sessionId: v.string(), interval: v.number() },
  handler: async (ctx, args) => {
    // Optionally gate by membership for /board/$id:
    // await canReadBoard(ctx, args.roomId as Id<"boards">);
    return await presence.heartbeat(ctx, args.roomId, args.userId, args.sessionId, args.interval);
  },
});

export const list = query({
  args: { roomToken: v.string() },
  handler: async (ctx, { roomToken }) => {
    return await presence.list(ctx, roomToken);
  },
});

export const disconnect = mutation({
  args: { sessionToken: v.string() },
  handler: async (ctx, { sessionToken }) => {
    return await presence.disconnect(ctx, sessionToken);
  },
});

// High-frequency cursor pulses are a separate, tiny write path.
export const cursorPulse = mutation({
  args: {
    boardId: v.id("boards"),
    sessionId: v.string(),
    userId: v.string(),
    name: v.string(),
    color: v.string(),
    x: v.number(), y: v.number(),
  },
  handler: async (ctx, { boardId, sessionId, userId, name, color, x, y }) => {
    const now = Date.now();
    // upsert per (board, session)
    const existing = await ctx.db
      .query("cursors")
      .withIndex("by_board_session", q => q.eq("boardId", boardId).eq("sessionId", sessionId))
      .first();

    if (existing) {
      await ctx.db.patch(existing._id, { x, y, updatedAt: now });
    } else {
      await ctx.db.insert("cursors", { boardId, sessionId, userId, name, color, x, y, updatedAt: now });
    }
  },
});

export const cursorsByBoard = query({
  args: { boardId: v.id("boards") },
  handler: async (ctx, { boardId }) => {
    const cutoff = Date.now() - 1500; // ~1.5s freshness window
    const all = await ctx.db
      .query("cursors")
      .withIndex("by_board", q => q.eq("boardId", boardId))
      .collect();
    return all.filter(c => c.updatedAt >= cutoff);
  },
});
```

> Presence component API (convex.config + heartbeat/list/disconnect) is taken directly from the docs; cursor payload rides a separate path to keep live queries scoped and cheap. ([Convex][2])

---

## Client: TanStack Start + React

### `src/app.tsx` (Convex provider + auth boundary)

```tsx
import * as React from "react";
import { ConvexProvider, ConvexReactClient } from "convex/react";
// Swap for ConvexProviderWithAuth if/when you add Convex Auth UI
const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL!);

export function AppProviders({ children }: { children: React.ReactNode }) {
  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
}
```

(Convex React client wiring; for Convex Auth, use `ConvexProviderWithAuth` and provide a `useAuth` hook or the Convex Auth actions as documented.) ([docs.convex.dev][7])

### `src/routes/__root.tsx`

```tsx
import { createRootRoute, Outlet } from "@tanstack/react-router";
import { AppProviders } from "../app";

export const Route = createRootRoute({
  component: () => (
    <AppProviders>
      <Outlet />
    </AppProviders>
  ),
});
```

### `src/routes/board.$boardId.tsx`

```tsx
import * as React from "react";
import { createFileRoute } from "@tanstack/react-router";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../convex/_generated/api";
import usePresence from "@convex-dev/presence/react";
import { useThrottle } from "../lib/throttle";
import { getSessionId } from "../lib/session";
import { NoteCard } from "../components/NoteCard";
import { CursorLayer } from "../components/CursorLayer";

export const Route = createFileRoute("/board/$boardId")({
  component: BoardPage,
});

function BoardPage() {
  const { boardId } = Route.useParams();
  const sessionId = React.useMemo(getSessionId, []);
  const name = React.useMemo(() => "User " + sessionId.slice(-4), [sessionId]);
  const color = React.useMemo(() => HUES[Math.abs(hash(sessionId)) % HUES.length], [sessionId]);

  // Live notes
  const notes = useQuery(api.notes.list, { boardId }) ?? [];
  const upsert = useMutation(api.notes.upsert);

  // Presence membership (join/leave/heartbeat handled by the component)
  usePresence(api.presence, boardId, name); // roomId === boardId
  // Live cursors
  const cursors = useQuery(api.presence.cursorsByBoard, { boardId }) ?? [];
  const pulse = useMutation(api.presence.cursorPulse);

  // Throttled pointer pulse (quantize to 2px, 30-60Hz)
  const sendPulse = useThrottle(async (x: number, y: number) => {
    const qx = Math.round(x / 2) * 2, qy = Math.round(y / 2) * 2;
    await pulse({ boardId, sessionId, userId: sessionId, name, color, x: qx, y: qy });
  }, 16); // ~60Hz max

  return (
    <div
      className="board"
      onPointerMove={e => sendPulse(e.clientX, e.clientY)}
      style={{ position: "relative", width: "100%", height: "100dvh", overflow: "hidden" }}
    >
      {notes.map(n => (
        <NoteCard
          key={n._id}
          note={n}
          onDragEnd={async (nx, ny) => {
            await upsert({
              noteId: n._id, boardId, x: nx, y: ny, width: n.width, height: n.height,
              text: n.text, color: n.color, z: n.z, expectedUpdatedAt: n.updatedAt,
            });
          }}
        />
      ))}
      <CursorLayer me={{ name, color, sessionId }} peers={cursors} />
    </div>
  );
}

// utils
const HUES = ["#f97316", "#22c55e", "#06b6d4", "#8b5cf6", "#ef4444"];
function hash(s: string) { let h=0; for (let i=0;i<s.length;i++) h = (h<<5)-h + s.charCodeAt(i); return h|0; }
```

### `src/components/CursorLayer.tsx`

```tsx
export function CursorLayer({
  me,
  peers,
}: {
  me: { name: string; color: string; sessionId: string };
  peers: { sessionId: string; name: string; color: string; x: number; y: number }[];
}) {
  return (
    <svg style={{ position: "absolute", inset: 0, pointerEvents: "none" }}>
      {peers
        .filter(p => p.sessionId !== me.sessionId)
        .map(p => (
          <g key={p.sessionId} transform={`translate(${p.x}, ${p.y})`}>
            <circle r={4} fill={p.color} />
            <text x={8} y={4} fontSize={11} fill="#222" style={{ userSelect: "none" }}>
              {p.name}
            </text>
          </g>
        ))}
    </svg>
  );
}
```

### `src/components/NoteCard.tsx` (indicative)

```tsx
import * as React from "react";

export function NoteCard({
  note,
  onDragEnd,
}: {
  note: { _id: string; x: number; y: number; width: number; height: number; text: string; color: string; z: number };
  onDragEnd: (x: number, y: number) => void;
}) {
  const [pos, setPos] = React.useState({ x: note.x, y: note.y });
  React.useEffect(() => setPos({ x: note.x, y: note.y }), [note.x, note.y]);

  const dragging = React.useRef(false);
  const start = React.useRef({ x: 0, y: 0 });

  return (
    <div
      style={{
        position: "absolute",
        left: pos.x, top: pos.y, width: note.width, height: note.height, zIndex: note.z,
        background: note.color, padding: 8, borderRadius: 6, cursor: "grab", userSelect: "none",
      }}
      onPointerDown={e => { dragging.current = true; start.current = { x: e.clientX - pos.x, y: e.clientY - pos.y }; (e.currentTarget as HTMLElement).setPointerCapture(e.pointerId); }}
      onPointerMove={e => { if (!dragging.current) return; setPos({ x: e.clientX - start.current.x, y: e.clientY - start.current.y }); }}
      onPointerUp={e => { if (!dragging.current) return; dragging.current = false; (e.currentTarget as HTMLElement).releasePointerCapture(e.pointerId); onDragEnd(pos.x, pos.y); }}
    >
      {note.text}
    </div>
  );
}
```

### `src/lib/throttle.ts`

```ts
export function useThrottle<T extends (...a: any[]) => any>(fn: T, ms: number): T {
  let last = 0; let queued: any[] | null = null; let raf = 0;
  return ((...args: any[]) => {
    const now = performance.now();
    if (now - last >= ms) { last = now; fn(...args); }
    else { queued = args; if (!raf) raf = requestAnimationFrame(() => { raf = 0; if (queued) { last = performance.now(); fn(...queued); queued = null; } }); }
  }) as T;
}
```

### `src/lib/session.ts`

```ts
export function getSessionId() {
  const key = "cb.sessionId";
  let id = sessionStorage.getItem(key);
  if (!id) { id = crypto.randomUUID(); sessionStorage.setItem(key, id); }
  return id;
}
```

---

## Self‑hosting (staging)

Use the official compose from the Convex repo as your baseline. This exposes the backend on `3210` (API / live queries) and `3211` (HTTP actions). The dashboard runs on `6791`. You can start with SQLite (default) or set `DATABASE_URL` / `POSTGRES_URL` to point at Neon/RDS. Pin versions for production. ([GitHub][8])

`docker/docker-compose.yml` (minimalized from the official one):

```yaml
services:
  backend:
    image: ghcr.io/get-convex/convex-backend:latest
    stop_grace_period: 10s
    ports:
      - "3210:3210"   # api
      - "3211:3211"   # http actions
    environment:
      - CONVEX_CLOUD_ORIGIN=http://127.0.0.1:3210
      - CONVEX_SITE_ORIGIN=http://127.0.0.1:3211
      # For Postgres, set one of these per docs:
      # - DATABASE_URL=postgres://user:pass@host:5432/db
      # or
      # - POSTGRES_URL=postgres://user:pass@host:5432/db
    volumes:
      - convex_data:/convex/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3210/version"]
      interval: 5s
      start_period: 10s

  dashboard:
    image: ghcr.io/get-convex/convex-dashboard:latest
    ports:
      - "6791:6791"
    environment:
      - NEXT_PUBLIC_DEPLOYMENT_URL=http://127.0.0.1:3210
    depends_on:
      backend:
        condition: service_healthy

volumes:
  convex_data: {}
```

(Directly follows the upstream compose file; see that file for all supported env vars including `DATABASE_URL`, `POSTGRES_URL`, `DO_NOT_REQUIRE_SSL`, S3 buckets, etc.) ([GitHub][8])

---

## Auth now, OIDC later

* Start with **Convex Auth** for a frictionless beta; it’s explicitly **beta**, so keep the adapter boundary thin as your ADR says. ([docs.convex.dev][4])
* If you prefer an external provider: use `ConvexProviderWithAuth` and pass the provider’s `useAuth` (Clerk/Auth.js/Better Auth/etc.). Convex documents this integration pattern through `ConvexProviderWithAuth`. ([docs.convex.dev][9])

---

## Concurrency & edits

* **Drag/move**: sample client‑side (e.g., every 100–150ms) while dragging; commit full pos at drop via `notes.upsert`.
* **Text**: begin with **LWW** (as implemented) and a **soft lock** (`locks` table) for hints and UX (“Editing by Alice”).
* **If this becomes painful**: migrate the note body to a CRDT editor (Convex + ProseMirror component). ([Convex][6])

---

## Performance guidelines

* **Live queries** are already incremental; keep them **narrow** (always filter by `boardId` and index on `notes.by_board`).
* **Cursor pulses**: quantize (`2–4px`), throttle to **≤60Hz**, and read only **fresh** pulses (≤1.5s).
* **Colocate** app hosting with Convex backend region to minimize RTT.
* **Acceptance test** for perceived latency: add a `ping` mutation that returns server `Date.now()`; measure median RTT over 30 samples while moving, under 100–150ms typical on a colocated region.
* If you need to scale up self‑hosting later, the images support Postgres and you can run in Fly.io/Railway/Docker on a VM. ([GitHub][8])

---

## Security & authorization

* Wrap **every** query/mutation with `requireMember(boardId, role)` as above.
* Use the **RLS** blog pattern to centralize document‑level checks; keep `boardId` in every note and membership and index by it. ([Convex Stack][5])

---

## Hitting your ADR acceptance criteria

* **Self‑hosted Convex in staging**: launch with the compose file above; verify the dashboard at `:6791` and your API at `:3210`. ([GitHub][8])
* **Multi‑cursor <100ms perceived latency**: use the `cursorPulse` path + presence; throttle/quantize as in the route file.
* **Deterministic concurrent text edits**: LWW on `updatedAt`, with optional soft locks for UX.
* **Auth end‑to‑end**: drop in Convex Auth first (magic link/OAuth/password), keep the provider boundary thin for a future OIDC switch. ([docs.convex.dev][4])

---

## Notes & tiny corrections

* The presence package is published as **`@convex-dev/presence`** (repo lives under `get-convex/presence`). The usage in `convex.config.ts` + `convex/presence.ts` above mirrors the docs. ([Convex][2])
* TanStack Start RC announcement date matches your ADR (Sep 23, 2025). ([TanStack][3])
* For Docker images, prefer the **GHCR images** `ghcr.io/get-convex/convex-backend` and `ghcr.io/get-convex/convex-dashboard`, and keep them **pinned** in prod. The upstream compose exposes all supported env vars (including Postgres). ([GitHub][8])

---

If you want, you can copy these files in and run:

```bash
# 1) Start self-hosted Convex locally
docker compose -f docker/docker-compose.yml up -d

# 2) In the app: install & run
pnpm i
pnpm dev

# .env (client):
# VITE_CONVEX_URL=http://127.0.0.1:3210
```

This should give you a working `/board/:boardId` route with live notes + presence and smooth multi-cursor rendering, aligned with the ADR.

---

### References

* Convex self‑hosting docs; official compose with images & env vars. ([docs.convex.dev][1])
* Presence Convex Component (docs + repo). ([Convex][2])
* TanStack Start v1 RC announcement (Sep 23, 2025). ([TanStack][3])
* Convex Auth (beta) overview + guidance. ([docs.convex.dev][4])
* Row‑level security patterns in Convex. ([Convex Stack][5])
* ProseMirror sync component (future option). ([Convex][6])

---

If you’d like, I can also drop in a few tiny Jest/Playwright checks (RTT “ping”, lock expiry) and a pinned compose for Neon Postgres to make staging parity dead simple.

[1]: https://docs.convex.dev/self-hosting "Self Hosting | Convex Developer Hub"
[2]: https://www.convex.dev/components/presence "Presence"
[3]: https://tanstack.com/blog/announcing-tanstack-start-v1?utm_source=chatgpt.com "TanStack Start v1 Release Candidate"
[4]: https://docs.convex.dev/auth/convex-auth?utm_source=chatgpt.com "Convex Auth | Convex Developer Hub"
[5]: https://stack.convex.dev/row-level-security?utm_source=chatgpt.com "Row Level Security"
[6]: https://www.convex.dev/components/prosemirror-sync?utm_source=chatgpt.com "Collaborative Text Editor Sync"
[7]: https://docs.convex.dev/client/react?utm_source=chatgpt.com "Convex React | Convex Developer Hub"
[8]: https://raw.githubusercontent.com/get-convex/convex-backend/main/self-hosted/docker/docker-compose.yml?utm_source=chatgpt.com "https://raw.githubusercontent.com/get-convex/conve..."
[9]: https://docs.convex.dev/api/modules/react?utm_source=chatgpt.com "Module: react | Convex Developer Hub"
