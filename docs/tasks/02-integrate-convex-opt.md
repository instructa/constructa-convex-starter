# Integrate Convex (Optimized Plan)

This is an optimized plan for integrating Convex into the collaborative board app, focusing on cloud-hosted Convex with TanStack Start RC1. No auth, no concurrency handling, no self-hosting.

## Minimal repo layout

```
collab-board/
├─ convex/
│  ├─ convex.config.ts          # mounts the Presence component
│  ├─ schema.ts                 # boards, notes, cursors tables
│  ├─ notes.ts                  # notes.list, notes.upsert for live notes
│  ├─ presence.ts               # wire up @convex-dev/presence + cursor pulses
│  └─ _generated/…              # generated by Convex
├─ src/
│  ├─ app.tsx                   # Convex provider
│  ├─ routes/
│  │  ├─ __root.tsx
│  │  └─ board.$boardId.tsx     # board page: notes + presence + cursors
│  ├─ components/
│  │  ├─ NoteCard.tsx
│  │  └─ CursorLayer.tsx
│  └─ lib/
│     ├─ throttle.ts
│     └─ session.ts             # per-tab session id
├─ .env.example
├─ package.json
├─ tsconfig.json
└─ README.md
```

## Task List

### Backend Setup
- [ ] Initialize Convex project with `npx convex dev --once`
- [ ] Configure `convex.config.ts` with Presence component
- [ ] Create simplified `schema.ts` (boards, notes, cursors tables only)
- [ ] Implement `notes.ts` with basic list and upsert mutations (no auth/RLS)
- [ ] Set up `presence.ts` for cursor tracking and room presence

### Frontend Setup
- [ ] Update `src/app.tsx` with Convex provider
- [ ] Ensure `__root.tsx` wraps routes with Convex provider
- [ ] Create `board.$boardId.tsx` route with live notes and cursors
- [ ] Implement `NoteCard.tsx` component for draggable notes
- [ ] Create `CursorLayer.tsx` for multi-user cursor display
- [ ] Add utility functions (`throttle.ts`, `session.ts`)

### Configuration & Deployment
- [ ] Set up environment variables (`.env.example` with `VITE_CONVEX_URL`)
- [ ] Install required dependencies (`convex`, `@convex-dev/presence`)
- [ ] Configure Convex dashboard and deploy
- [ ] Test basic functionality (create/move notes, cursor presence)
- [ ] Deploy frontend to Vercel with proper Convex URL

## Server: Convex setup

### `convex/convex.config.ts`

```ts
import { defineApp } from "convex/server";
import presence from "@convex-dev/presence/convex.config";

const app = defineApp();
app.use(presence); // mounts presence functions under api.presence.*
export default app;
```

### `convex/schema.ts`

```ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  boards: defineTable({
    name: v.string(),
    createdAt: v.number(),
  }),

  notes: defineTable({
    boardId: v.id("boards"),
    x: v.number(), y: v.number(),
    width: v.number(), height: v.number(),
    text: v.string(),
    color: v.string(),
    z: v.number(),
    updatedAt: v.number(),
  }).index("by_board", ["boardId"]),

  cursors: defineTable({
    boardId: v.id("boards"),
    sessionId: v.string(),
    userId: v.string(),
    name: v.string(),
    color: v.string(),
    x: v.number(),
    y: v.number(),
    updatedAt: v.number(),
  })
    .index("by_board", ["boardId"])
    .index("by_board_session", ["boardId", "sessionId"]),
});
```

### `convex/notes.ts`

```ts
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

export const list = query({
  args: { boardId: v.id("boards") },
  handler: async (ctx, { boardId }) => {
    return await ctx.db
      .query("notes")
      .withIndex("by_board", q => q.eq("boardId", boardId))
      .collect();
  },
});

export const upsert = mutation({
  args: {
    noteId: v.optional(v.id("notes")),
    boardId: v.id("boards"),
    x: v.number(), y: v.number(),
    width: v.number(), height: v.number(),
    text: v.string(),
    color: v.string(),
    z: v.number(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();

    if (args.noteId) {
      await ctx.db.patch(args.noteId, {
        x: args.x, y: args.y, width: args.width, height: args.height,
        text: args.text, color: args.color, z: args.z, updatedAt: now,
      });
      return await ctx.db.get(args.noteId);
    } else {
      const id = await ctx.db.insert("notes", {
        boardId: args.boardId,
        x: args.x, y: args.y, width: args.width, height: args.height,
        text: args.text, color: args.color, z: args.z,
        updatedAt: now,
      });
      return await ctx.db.get(id);
    }
  },
});
```

### `convex/presence.ts`

```ts
import { mutation, query } from "./_generated/server";
import { components } from "./_generated/api";
import { v } from "convex/values";
import { Presence } from "@convex-dev/presence";

export const presence = new Presence(components.presence);

export const heartbeat = mutation({
  args: { roomId: v.string(), userId: v.string(), sessionId: v.string(), interval: v.number() },
  handler: async (ctx, args) => {
    return await presence.heartbeat(ctx, args.roomId, args.userId, args.sessionId, args.interval);
  },
});

export const list = query({
  args: { roomToken: v.string() },
  handler: async (ctx, { roomToken }) => {
    return await presence.list(ctx, roomToken);
  },
});

export const disconnect = mutation({
  args: { sessionToken: v.string() },
  handler: async (ctx, { sessionToken }) => {
    return await presence.disconnect(ctx, sessionToken);
  },
});

export const cursorPulse = mutation({
  args: {
    boardId: v.id("boards"),
    sessionId: v.string(),
    userId: v.string(),
    name: v.string(),
    color: v.string(),
    x: v.number(), y: v.number(),
  },
  handler: async (ctx, { boardId, sessionId, userId, name, color, x, y }) => {
    const now = Date.now();
    const existing = await ctx.db
      .query("cursors")
      .withIndex("by_board_session", q => q.eq("boardId", boardId).eq("sessionId", sessionId))
      .first();

    if (existing) {
      await ctx.db.patch(existing._id, { x, y, updatedAt: now });
    } else {
      await ctx.db.insert("cursors", { boardId, sessionId, userId, name, color, x, y, updatedAt: now });
    }
  },
});

export const cursorsByBoard = query({
  args: { boardId: v.id("boards") },
  handler: async (ctx, { boardId }) => {
    const cutoff = Date.now() - 1500;
    const all = await ctx.db
      .query("cursors")
      .withIndex("by_board", q => q.eq("boardId", boardId))
      .collect();
    return all.filter(c => c.updatedAt >= cutoff);
  },
});
```

## Client: TanStack Start + React

### `src/app.tsx`

```tsx
import * as React from "react";
import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL!);

export function AppProviders({ children }: { children: React.ReactNode }) {
  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
}
```

### `src/routes/__root.tsx`

```tsx
import { createRootRoute, Outlet } from "@tanstack/react-router";
import { AppProviders } from "../app";

export const Route = createRootRoute({
  component: () => (
    <AppProviders>
      <Outlet />
    </AppProviders>
  ),
});
```

### `src/routes/board.$boardId.tsx`

```tsx
import * as React from "react";
import { createFileRoute } from "@tanstack/react-router";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../convex/_generated/api";
import usePresence from "@convex-dev/presence/react";
import { useThrottle } from "../lib/throttle";
import { getSessionId } from "../lib/session";
import { NoteCard } from "../components/NoteCard";
import { CursorLayer } from "../components/CursorLayer";

export const Route = createFileRoute("/board/$boardId")({
  component: BoardPage,
});

function BoardPage() {
  const { boardId } = Route.useParams();
  const sessionId = React.useMemo(getSessionId, []);
  const name = React.useMemo(() => "User " + sessionId.slice(-4), [sessionId]);
  const color = React.useMemo(() => HUES[Math.abs(hash(sessionId)) % HUES.length], [sessionId]);

  const notes = useQuery(api.notes.list, { boardId }) ?? [];
  const upsert = useMutation(api.notes.upsert);

  usePresence(api.presence, boardId, name);
  const cursors = useQuery(api.presence.cursorsByBoard, { boardId }) ?? [];
  const pulse = useMutation(api.presence.cursorPulse);

  const sendPulse = useThrottle(async (x: number, y: number) => {
    const qx = Math.round(x / 2) * 2, qy = Math.round(y / 2) * 2;
    await pulse({ boardId, sessionId, userId: sessionId, name, color, x: qx, y: qy });
  }, 16);

  return (
    <div
      className="board"
      onPointerMove={e => sendPulse(e.clientX, e.clientY)}
      style={{ position: "relative", width: "100%", height: "100dvh", overflow: "hidden" }}
    >
      {notes.map(n => (
        <NoteCard
          key={n._id}
          note={n}
          onDragEnd={async (nx, ny) => {
            await upsert({
              noteId: n._id, boardId, x: nx, y: ny, width: n.width, height: n.height,
              text: n.text, color: n.color, z: n.z,
            });
          }}
        />
      ))}
      <CursorLayer me={{ name, color, sessionId }} peers={cursors} />
    </div>
  );
}

const HUES = ["#f97316", "#22c55e", "#06b6d4", "#8b5cf6", "#ef4444"];
function hash(s: string) { let h=0; for (let i=0;i<s.length;i++) h = (h<<5)-h + s.charCodeAt(i); return h|0; }
```

### `src/components/CursorLayer.tsx`

```tsx
export function CursorLayer({
  me,
  peers,
}: {
  me: { name: string; color: string; sessionId: string };
  peers: { sessionId: string; name: string; color: string; x: number; y: number }[];
}) {
  return (
    <svg style={{ position: "absolute", inset: 0, pointerEvents: "none" }}>
      {peers
        .filter(p => p.sessionId !== me.sessionId)
        .map(p => (
          <g key={p.sessionId} transform={`translate(${p.x}, ${p.y})`}>
            <circle r={4} fill={p.color} />
            <text x={8} y={4} fontSize={11} fill="#222" style={{ userSelect: "none" }}>
              {p.name}
            </text>
          </g>
        ))}
    </svg>
  );
}
```

### `src/components/NoteCard.tsx`

```tsx
import * as React from "react";

export function NoteCard({
  note,
  onDragEnd,
}: {
  note: { _id: string; x: number; y: number; width: number; height: number; text: string; color: string; z: number };
  onDragEnd: (x: number, y: number) => void;
}) {
  const [pos, setPos] = React.useState({ x: note.x, y: note.y });
  React.useEffect(() => setPos({ x: note.x, y: note.y }), [note.x, note.y]);

  const dragging = React.useRef(false);
  const start = React.useRef({ x: 0, y: 0 });

  return (
    <div
      style={{
        position: "absolute",
        left: pos.x, top: pos.y, width: note.width, height: note.height, zIndex: note.z,
        background: note.color, padding: 8, borderRadius: 6, cursor: "grab", userSelect: "none",
      }}
      onPointerDown={e => { dragging.current = true; start.current = { x: e.clientX - pos.x, y: e.clientY - pos.y }; (e.currentTarget as HTMLElement).setPointerCapture(e.pointerId); }}
      onPointerMove={e => { if (!dragging.current) return; setPos({ x: e.clientX - start.current.x, y: e.clientY - start.current.y }); }}
      onPointerUp={e => { if (!dragging.current) return; dragging.current = false; (e.currentTarget as HTMLElement).releasePointerCapture(e.pointerId); onDragEnd(pos.x, pos.y); }}
    >
      {note.text}
    </div>
  );
}
```

### `src/lib/throttle.ts`

```ts
export function useThrottle<T extends (...a: any[]) => any>(fn: T, ms: number): T {
  let last = 0; let queued: any[] | null = null; let raf = 0;
  return ((...args: any[]) => {
    const now = performance.now();
    if (now - last >= ms) { last = now; fn(...args); }
    else { queued = args; if (!raf) raf = requestAnimationFrame(() => { raf = 0; if (queued) { last = performance.now(); fn(...queued); queued = null; } }); }
  }) as T;
}
```

### `src/lib/session.ts`

```ts
export function getSessionId() {
  const key = "cb.sessionId";
  let id = sessionStorage.getItem(key);
  if (!id) { id = crypto.randomUUID(); sessionStorage.setItem(key, id); }
  return id;
}
```

## Performance guidelines

* **Live queries** are already incremental; keep them **narrow** (always filter by `boardId` and index on `notes.by_board`).
* **Cursor pulses**: quantize (`2–4px`), throttle to **≤60Hz**, and read only **fresh** pulses (≤1.5s).
* **Acceptance test** for perceived latency: add a `ping` mutation that returns server `Date.now()`; measure median RTT over 30 samples while moving, under 100–150ms typical.

## Getting Started

```bash
# Install dependencies
pnpm add convex @convex-dev/presence

# Initialize Convex
npx convex dev --once

# Set up environment
# Add VITE_CONVEX_URL to .env (get from Convex dashboard)

# Run development server
pnpm dev
```

This provides a working collaborative board with live notes and multi-cursor presence using cloud-hosted Convex.
